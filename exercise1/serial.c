#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>
#include <string.h>
#include <getopt.h>

struct timespec ts;
#define CPU_TIME (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts), (double)ts.tv_sec + (double)ts.tv_nsec * 1e-9)

#define XWIDTH 256
#define YWIDTH 256
#define MAXVAL 255

#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (((mem) & (short int)0xff00) >> 8) + \
                      (((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif

// =============================================================
//  utilities for managinf pgm files
// =============================================================

void write_pgm_image(void *image, int maxval, int xsize, int ysize, const char *image_name)
{
  FILE *image_file;
  image_file = fopen(image_name, "w");
  if (image_file == NULL)
  {
    fprintf(stderr, "Error opening file %s for writing.\n", image_name);
    return; // Exit the function if file opening failed
  }

  int color_depth = 1 + (maxval > 255);

  fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);

  fwrite(image, 1, xsize * ysize * color_depth, image_file);

  fclose(image_file);
  return;
}

void read_pgm_image(void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
{
  FILE *image_file;
  image_file = fopen(image_name, "r");

  *image = NULL;
  *xsize = *ysize = *maxval = 0;

  char MagicN[2];
  char *line = NULL;
  size_t k, n = 0;

  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN);

  // skip all the comments
  k = getline(&line, &n, image_file);
  while ((k > 0) && (line[0] == '#'))
    k = getline(&line, &n, image_file);

  if (k > 0)
  {
    k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
    if (k < 3)
      fscanf(image_file, "%d%*c", maxval);
  }
  else
  {
    *maxval = -1; // this is the signal that there was an I/O error
                  // while reading the image header
    free(line);
    return;
  }
  free(line);

  int color_depth = 1 + (*maxval > 255);
  unsigned int size = *xsize * *ysize * color_depth;

  if ((*image = (char *)malloc(size)) == NULL)
  {
    fclose(image_file);
    *maxval = -2; // this is the signal that memory was insufficient
    *xsize = 0;
    *ysize = 0;
    return;
  }

  if (fread(*image, 1, size, image_file) != size)
  {
    free(image);
    image = NULL;
    *maxval = -3; // this is the signal that there was an i/o error
    *xsize = 0;
    *ysize = 0;
  }

  fclose(image_file);
  return;
}

// =============================================================
//  utilities for managing the playground
// =============================================================

// Need to implement utility functions such as
// - init_playground,
// - load_playground,
// - save_playground,
// - update_cell,
// - ordered_evolution,
// - static_evolution.

// --------------------------------------------------------------------------------------------- //
// Implement the function init_playground that initializes a playground of size xsize * ysize.
// --------------------------------------------------------------------------------------------- //

void *init_playground(int xsize, int ysize)
{
  srand(time(NULL)); // different seed each time the playground is initialized

  // Allocate memory for the image
  unsigned char *image = (unsigned char *)malloc(xsize * ysize * sizeof(unsigned char));

  // Generate random black-and-white pixel values
  for (int y = 0; y < ysize; y++)
  {
    for (int x = 0; x < xsize; x++)
    {
      image[y * xsize + x] = (rand() % 2) * MAXVAL;
    }
  }

  // Return the pointer to the allocated memory
  return (void *)image;
}

// --------------------------------------------------------------------------------------------- //
// ORDERED: Implement the function update_ordered_cell that updates the value of a cell in the playground after looked the neighbors.
// --------------------------------------------------------------------------------------------- //

void update_ordered_cell(unsigned char *playground, int xsize, int ysize, int x, int y)
{

  for (int y = 0; y < ysize; y++)
  {
    for (int x = 0; x < xsize; x++)
    {
      printf("%d ", playground[y * xsize + x] == MAXVAL ? 1 : 0);
    }
    printf("\n");
  }

  int alive_neighbors = 0;
  int nx, ny = 0;
  for (int i = -1; i <= 1; i++)
  {
    for (int j = -1; j <= 1; j++)
    {
      if (i == 0 && j == 0)
        continue; // process in the next iteration of the loop
      nx = (x + i + xsize) % xsize;
      ny = (y + j + ysize) % ysize;

      alive_neighbors += (playground[ny * xsize + nx] == MAXVAL); // how many neighbors cells are equal to MAXVAL=255, i.e., alive!
    }
  }
  printf("Cell at (%d, %d) has %d alive neighbors\n", x, y, alive_neighbors); // print the total count of alive neighbors for the cell

  int cell_index = y * xsize + x;
  // update the cell value based on the number of alive neighbors

  // playground[cell_index] = (alive_neighbors == 2 || alive_neighbors == 3) ? 255 : 0;
  playground[cell_index] = ((((playground[cell_index] == 255) && (alive_neighbors == 2 || alive_neighbors == 3)) || ((playground[cell_index] == 0) && alive_neighbors == 3))) ? 255 : 0;
}

void ordered_evolution(unsigned char *playground, int xsize, int ysize, int n)
{

  for (int step = 0; step < n; step++)
  {
    for (int y = 0; y < ysize; y++)
    {
      for (int x = 0; x < xsize; x++)
      {
        update_ordered_cell(playground, xsize, ysize, x, y);
      }
    }

    char filename[256];                                                       // Ensure this is large enough to handle the path and filename
    sprintf(filename, "media_serial/ordered/%d_test_dump_ordered.pgm", step); // Formatting the filename with the step number

    // Write the PGM image
    write_pgm_image((void *)playground, 255, xsize, ysize, filename);
  }
}

//--------------------------------------------------------------------------------------------- //
// STATIC: Implement the function update_cell_static that updates the value of a cell looking at the neighbors of the past playground.
//--------------------------------------------------------------------------------------------- //

void update_cell_static(const unsigned char *old_playground, unsigned char *new_playground, int xsize, int ysize, int x, int y)
{

  int alive_neighbors = 0;
  int nx, ny = 0;
  for (int i = -1; i <= 1; i++)
  {
    for (int j = -1; j <= 1; j++)
    {
      if (i == 0 && j == 0)
        continue;

      int nx = (x + i + xsize) % xsize;
      int ny = (y + j + ysize) % ysize;
      alive_neighbors += (old_playground[ny * xsize + nx] == MAXVAL);
    }
  }
  printf("Cell at (%d, %d) has %d alive neighbors\n", x, y, alive_neighbors); // print the total count of alive neighbors for the cell

  int cell_index = y * xsize + x;
  // printf("cell coordinates: (%d,%d), value: %d, alive neighbors: %d, ", x, y, old_playground[cell_index], alive_neighbors);

  // new_playground[cell_index] = (alive_neighbors == 2 || alive_neighbors == 3) ? 255 : 0;
  new_playground[cell_index] = (((old_playground[cell_index] == 255) && (alive_neighbors == 2 || alive_neighbors == 3)) || ((old_playground[cell_index] == 0) && alive_neighbors == 3)) ? 255 : 0;
  // printf("updated playground: %d", new_playground[cell_index]);
}

void static_evolution(unsigned char *playground, int xsize, int ysize, int n)
{
  unsigned char *new_playground = (unsigned char *)malloc(xsize * ysize * sizeof(unsigned char));

  for (int step = 0; step < n; step++)
  {

    for (int y = 0; y < ysize; y++)
    {
      for (int x = 0; x < xsize; x++)
      {
        update_cell_static(playground, new_playground, xsize, ysize, x, y);
      }
    }
    for (int y = 0; y < ysize; y++)
    {
      for (int x = 0; x < xsize; x++)
      {
        printf("%d ", playground[y * xsize + x] == MAXVAL ? 1 : 0);
        printf("%d ", new_playground[y * xsize + x] == MAXVAL ? 1 : 0);
      }
      printf("\n");
    }

    memcpy(playground, new_playground, xsize * ysize * sizeof(unsigned char));

    char filename[256];                                                     // Ensure this is large enough to handle the path and filename
    sprintf(filename, "media_serial/static/%d_test_dump_static.pgm", step); // Formatting the filename with the step number

    // Write the PGM image
    write_pgm_image((void *)playground, 255, xsize, ysize, filename);
  }

  free(new_playground);
}

#define INIT 1
#define RUN 2
#define K_DFLT 100
#define ORDERED 0
#define STATIC 1

// char fname_deflt[] = "game_of_life.pgm";

int action = 0;
int k = K_DFLT;     // size of the squared  playground
int e = ORDERED;    // evolution type [0\1]
int n = 10000;      // number of iterations
int s = 1;          // every how many steps a dump of the system is saved on a file, 0 meaning only at the end.
char *fname = NULL; // name of the file to be either read or written

int main(int argc, char **argv)
{
  /*Each character in the optstring represents a single-character
    option that the program accepts. If a character is followed by a colon (:),
    it indicates that the option requires an argument.
     -i: No argument required. Initialize playground.
     -r: No argument required. Run a playground.
     -k: Requires an argument (e.g., -k 100). Playground size.
     -e: Requires an argument (e.g., -e 1). Evolution type.
     -f: Requires an argument (e.g., -f filename.pgm).
     Name of the file to be either read or written
     -n: Requires an argument (e.g., -n 10000). Number of steps.
     -s: Requires an argument (e.g., -s 1). Frequency of dump.*/
  char *optstring = "irk:e:f:n:s:";
  int maxval = 255;
  int c;
  /*When the getopt function is called in the while loop,
    it processes the command-line arguments according to
    the format specified in optstring.
    The getopt function returns the next option character or -1 if there are no more options
 */
  while ((c = getopt(argc, argv, optstring)) != -1)
  {
    switch (c)
    {

    case 'i':
      action = INIT;

      break;

    case 'r':
      action = RUN;
      break;

    case 'k':
      k = atoi(optarg);
      break;

    case 'e':
      e = atoi(optarg);
      break;

    case 'f':
      fname = (char *)malloc(sizeof(optarg) + 1);
      sprintf(fname, "%s", optarg);
      break;

    case 'n':
      n = atoi(optarg);
      break;

    case 's':
      s = atoi(optarg);
      break;

    default:
      printf("argument -%c not known\n", c);
      break;
    }
  }

  if (action == INIT)
  {
    void *ptr = init_playground(k, k);
    write_pgm_image(ptr, 255, k, k, fname);
    free(ptr);
  }

  if (action == RUN)
  {
    if (e == ORDERED)
    {
      unsigned char *playground_o = (unsigned char *)malloc(k * k * sizeof(unsigned char));
      read_pgm_image((void **)&playground_o, &maxval, &k, &k, fname);
      double t_start = CPU_TIME;
      ordered_evolution(playground_o, k, k, n);
      double time = CPU_TIME - t_start;
      printf("elapsed time ordered: %f sec\n\n", time);
      write_pgm_image((void *)playground_o, 255, k, k, "test_dump_ordered.pgm");
      free(playground_o);
    }
    else if (e == STATIC)
    {
      unsigned char *playground_s = (unsigned char *)malloc(k * k * sizeof(unsigned char));
      read_pgm_image((void **)&playground_s, &maxval, &k, &k, fname);
      double t_start = CPU_TIME;
      static_evolution(playground_s, k, k, n);
      double time = CPU_TIME - t_start;
      printf("elapsed time static: %f sec\n\n", time);
      write_pgm_image((void *)playground_s, 255, k, k, "test_dump_static.pgm");
      free(playground_s);
    }

    else
    {
      printf("Error!");
    }
  }

  if (fname != NULL)
    free(fname);

  return 0;
}
